<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Abstract</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; width: 100vw; height: 100vh; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, t = 0;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// --- Particle system ---
const PARTICLES = 180;
const particles = [];

class Particle {
  constructor() { this.reset(true); }
  reset(init) {
    this.x = Math.random() * W;
    this.y = init ? Math.random() * H : H + 10;
    this.baseX = this.x;
    this.vy = -(0.3 + Math.random() * 0.8);
    this.vx = (Math.random() - 0.5) * 0.3;
    this.size = 0.5 + Math.random() * 2;
    this.life = 0;
    this.maxLife = 200 + Math.random() * 300;
    this.hue = Math.random() * 60 + 180; // teal-blue-purple range
    this.sat = 60 + Math.random() * 40;
    this.wave = Math.random() * Math.PI * 2;
    this.waveSpeed = 0.01 + Math.random() * 0.02;
    this.waveAmp = 20 + Math.random() * 60;
  }
  update() {
    this.life++;
    this.wave += this.waveSpeed;
    this.x = this.baseX + Math.sin(this.wave) * this.waveAmp;
    this.baseX += this.vx;
    this.y += this.vy;
    if (this.life > this.maxLife || this.y < -20) this.reset(false);
  }
  draw() {
    const alpha = Math.sin((this.life / this.maxLife) * Math.PI);
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${this.hue}, ${this.sat}%, 75%, ${alpha * 0.8})`;
    ctx.fill();
  }
}

for (let i = 0; i < PARTICLES; i++) particles.push(new Particle());

// --- Flowing ribbons ---
class Ribbon {
  constructor(i, total) {
    this.i = i;
    this.total = total;
    this.phase = (i / total) * Math.PI * 2;
    this.speed = 0.004 + i * 0.0003;
    this.width = 1 + Math.random() * 2;
    this.hue = (i / total) * 280 + 160;
    this.amp1 = 80 + Math.random() * 120;
    this.amp2 = 40 + Math.random() * 80;
    this.freq1 = 1.5 + Math.random();
    this.freq2 = 2.5 + Math.random();
  }
  getY(x, t) {
    const cx = (x / W - 0.5) * Math.PI * 2;
    return H / 2
      + Math.sin(cx * this.freq1 + t * this.speed * 60 + this.phase) * this.amp1
      + Math.sin(cx * this.freq2 - t * this.speed * 40 + this.phase * 1.3) * this.amp2
      + Math.cos(cx * 0.8 + t * 0.03 + this.phase * 0.7) * 30;
  }
  draw(t) {
    const steps = 120;
    ctx.beginPath();
    for (let s = 0; s <= steps; s++) {
      const x = (s / steps) * W;
      const y = this.getY(x, t);
      s === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    const alpha = 0.12 + 0.08 * Math.sin(t * this.speed * 50 + this.phase);
    ctx.strokeStyle = `hsla(${this.hue + Math.sin(t * 0.5) * 30}, 80%, 65%, ${alpha})`;
    ctx.lineWidth = this.width;
    ctx.stroke();

    // glow pass
    ctx.beginPath();
    for (let s = 0; s <= steps; s++) {
      const x = (s / steps) * W;
      const y = this.getY(x, t);
      s === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.strokeStyle = `hsla(${this.hue + Math.sin(t * 0.5) * 30}, 90%, 80%, ${alpha * 0.4})`;
    ctx.lineWidth = this.width * 4;
    ctx.stroke();
  }
}

const RIBBONS = 18;
const ribbons = Array.from({length: RIBBONS}, (_, i) => new Ribbon(i, RIBBONS));

// --- Metaballs / plasma blobs ---
class Blob {
  constructor(i) {
    this.cx = W * (0.2 + Math.random() * 0.6);
    this.cy = H * (0.2 + Math.random() * 0.6);
    this.r = 100 + Math.random() * 200;
    this.speedX = (Math.random() - 0.5) * 0.4;
    this.speedY = (Math.random() - 0.5) * 0.3;
    this.hue = 180 + i * 40 + Math.random() * 30;
    this.phaseX = Math.random() * Math.PI * 2;
    this.phaseY = Math.random() * Math.PI * 2;
    this.freqX = 0.003 + Math.random() * 0.005;
    this.freqY = 0.004 + Math.random() * 0.005;
  }
  update(t) {
    this.cx = W * (0.15 + 0.7 * (0.5 + 0.5 * Math.sin(t * this.freqX * 60 + this.phaseX)));
    this.cy = H * (0.15 + 0.7 * (0.5 + 0.5 * Math.sin(t * this.freqY * 60 + this.phaseY)));
  }
  draw() {
    const grad = ctx.createRadialGradient(this.cx, this.cy, 0, this.cx, this.cy, this.r);
    grad.addColorStop(0, `hsla(${this.hue}, 80%, 55%, 0.12)`);
    grad.addColorStop(1, `hsla(${this.hue}, 80%, 55%, 0)`);
    ctx.beginPath();
    ctx.arc(this.cx, this.cy, this.r, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();
  }
}

const blobs = Array.from({length: 6}, (_, i) => new Blob(i));

// --- Central vortex rings ---
function drawVortex(t) {
  const cx = W / 2, cy = H / 2;
  const rings = 12;
  for (let r = 0; r < rings; r++) {
    const progress = r / rings;
    const radius = 20 + progress * Math.min(W, H) * 0.38;
    const rotation = t * (0.2 + progress * 0.4) * (r % 2 === 0 ? 1 : -1);
    const sides = 5 + r;
    const hue = (t * 20 + r * 25) % 360;
    const alpha = 0.04 + 0.04 * Math.sin(t * 0.8 + r);

    ctx.beginPath();
    for (let s = 0; s <= sides; s++) {
      const angle = (s / sides) * Math.PI * 2 + rotation;
      const wobble = 1 + 0.06 * Math.sin(s * 3 + t * 2 + r);
      const x = cx + Math.cos(angle) * radius * wobble;
      const y = cy + Math.sin(angle) * radius * wobble;
      s === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.strokeStyle = `hsla(${hue}, 70%, 70%, ${alpha})`;
    ctx.lineWidth = 0.8;
    ctx.stroke();

    // bright inner highlight on some rings
    if (r % 3 === 0) {
      ctx.strokeStyle = `hsla(${hue + 30}, 90%, 90%, ${alpha * 1.5})`;
      ctx.lineWidth = 0.3;
      ctx.stroke();
    }
  }
}

// --- Scanline / chromatic aberration post pass ---
function drawScanlines() {
  ctx.fillStyle = 'rgba(0,0,0,0.015)';
  for (let y = 0; y < H; y += 3) {
    ctx.fillRect(0, y, W, 1);
  }
}

// --- Main loop ---
function draw() {
  t += 0.016;

  // Fade trail
  ctx.fillStyle = 'rgba(0, 0, 5, 0.18)';
  ctx.fillRect(0, 0, W, H);

  // Blobs (ambient light)
  blobs.forEach(b => { b.update(t); b.draw(); });

  // Ribbons
  ctx.globalCompositeOperation = 'screen';
  ribbons.forEach(r => r.draw(t));
  ctx.globalCompositeOperation = 'source-over';

  // Vortex
  drawVortex(t);

  // Particles
  ctx.globalCompositeOperation = 'screen';
  particles.forEach(p => { p.update(); p.draw(); });
  ctx.globalCompositeOperation = 'source-over';

  // Subtle scanlines
  drawScanlines();

  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
